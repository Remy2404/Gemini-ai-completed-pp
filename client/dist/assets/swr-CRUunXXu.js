import{R as be,r as E}from"./react-BDj6g8P4.js";import{s as ze}from"./use-sync-external-store-ZcNXlPZC.js";const oe=()=>{},N=oe(),Te=Object,i=e=>e===N,$=e=>typeof e=="function",te=(e,n)=>({...e,...n}),lt=e=>$(e.then),De=new WeakMap;let ft=0;const Ce=e=>{const n=typeof e,s=e&&e.constructor,c=s==Date;let r,a;if(Te(e)===e&&!c&&s!=RegExp){if(r=De.get(e),r)return r;if(r=++ft+"~",De.set(e,r),s==Array){for(r="@",a=0;a<e.length;a++)r+=Ce(e[a])+",";De.set(e,r)}if(s==Te){r="#";const R=Te.keys(e).sort();for(;!i(a=R.pop());)i(e[a])||(r+=a+":"+Ce(e[a])+",");De.set(e,r)}}else r=c?e.toJSON():n=="symbol"?e.toString():n=="string"?JSON.stringify(e):""+e;return r},Y=new WeakMap,ye={},me={},He="undefined",Ve=typeof window!=He,We=typeof document!=He,dt=()=>Ve&&typeof window.requestAnimationFrame!=He,re=(e,n)=>{const s=Y.get(e);return[()=>!i(n)&&e.get(n)||ye,c=>{if(!i(n)){const r=e.get(n);n in me||(me[n]=r),s[5](n,te(r,c),r||ye)}},s[6],()=>!i(n)&&n in me?me[n]:!i(n)&&e.get(n)||ye]};let xe=!0;const Et=()=>xe,[ke,qe]=Ve&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[oe,oe],Rt=()=>{const e=We&&document.visibilityState;return i(e)||e!=="hidden"},ht=e=>(We&&document.addEventListener("visibilitychange",e),ke("focus",e),()=>{We&&document.removeEventListener("visibilitychange",e),qe("focus",e)}),gt=e=>{const n=()=>{xe=!0,e()},s=()=>{xe=!1};return ke("online",n),ke("offline",s),()=>{qe("online",n),qe("offline",s)}},vt={isOnline:Et,isVisible:Rt},_t={initFocus:ht,initReconnect:gt},we=!be.useId,Ee=!Ve||"Deno"in window,Ge=e=>dt()?window.requestAnimationFrame(e):setTimeout(e,1),ce=Ee?E.useEffect:E.useLayoutEffect,Ne=typeof navigator<"u"&&navigator.connection,Ke=!Ee&&Ne&&(["slow-2g","2g"].includes(Ne.effectiveType)||Ne.saveData),ae=e=>{if($(e))try{e=e()}catch{e=""}const n=e;return e=typeof e=="string"?e:(Array.isArray(e)?e.length:e)?Ce(e):"",[e,n]};let St=0;const Oe=()=>++St,Xe=0,Qe=1,Ze=2,Tt=3;var ee={__proto__:null,ERROR_REVALIDATE_EVENT:Tt,FOCUS_EVENT:Xe,MUTATE_EVENT:Ze,RECONNECT_EVENT:Qe};async function $e(...e){const[n,s,c,r]=e,a=te({populateCache:!0,throwOnError:!0},typeof r=="boolean"?{revalidate:r}:r||{});let R=a.populateCache;const C=a.rollbackOnError;let h=a.optimisticData;const W=V=>typeof C=="function"?C(V):C!==!1,b=a.throwOnError;if($(s)){const V=s,f=[],x=n.keys();for(const S of x)!/^\$(inf|sub)\$/.test(S)&&V(n.get(S)._k)&&f.push(S);return Promise.all(f.map(D))}return D(s);async function D(V){const[f]=ae(V);if(!f)return;const[x,S]=re(n,f),[ue,t,H,B]=Y.get(n),U=()=>{const q=ue[f];return($(a.revalidate)?a.revalidate(x().data,V):a.revalidate!==!1)&&(delete H[f],delete B[f],q&&q[0])?q[0](Ze).then(()=>x().data):x().data};if(e.length<3)return U();let p=c,O;const J=Oe();t[f]=[J,0];const o=!i(h),k=x(),v=k.data,L=k._c,j=i(L)?v:L;if(o&&(h=$(h)?h(j,v):h,S({data:h,_c:j})),$(p))try{p=p(j)}catch(q){O=q}if(p&&lt(p))if(p=await p.catch(q=>{O=q}),J!==t[f][0]){if(O)throw O;return p}else O&&o&&W(O)&&(R=!0,S({data:j,_c:N}));if(R&&!O)if($(R)){const q=R(p,j);S({data:q,error:N,_c:N})}else S({data:p,error:N,_c:N});if(t[f][1]=Oe(),Promise.resolve(U()).then(()=>{S({_c:N})}),O){if(b)throw O;return}return p}}const Be=(e,n)=>{for(const s in e)e[s][0]&&e[s][0](n)},et=(e,n)=>{if(!Y.has(e)){const s=te(_t,n),c={},r=$e.bind(N,e);let a=oe;const R={},C=(b,D)=>{const V=R[b]||[];return R[b]=V,V.push(D),()=>V.splice(V.indexOf(D),1)},h=(b,D,V)=>{e.set(b,D);const f=R[b];if(f)for(const x of f)x(D,V)},W=()=>{if(!Y.has(e)&&(Y.set(e,[c,{},{},{},r,h,C]),!Ee)){const b=s.initFocus(setTimeout.bind(N,Be.bind(N,c,Xe))),D=s.initReconnect(setTimeout.bind(N,Be.bind(N,c,Qe)));a=()=>{b&&b(),D&&D(),Y.delete(e)}}};return W(),[e,r,W,a]}return[e,Y.get(e)[4]]},Ct=(e,n,s,c,r)=>{const a=s.errorRetryCount,R=r.retryCount,C=~~((Math.random()+.5)*(1<<(R<8?R:8)))*s.errorRetryInterval;!i(a)&&R>a||setTimeout(c,C,r)},pt=(e,n)=>Ce(e)==Ce(n),[pe,tt]=et(new Map),je=te({onLoadingSlow:oe,onSuccess:oe,onError:oe,onErrorRetry:Ct,onDiscarded:oe,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Ke?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Ke?5e3:3e3,compare:pt,isPaused:()=>!1,cache:pe,mutate:tt,fallback:{}},vt),nt=(e,n)=>{const s=te(e,n);if(n){const{use:c,fallback:r}=e,{use:a,fallback:R}=n;c&&a&&(s.use=c.concat(a)),r&&R&&(s.fallback=te(r,R))}return s},Ue=E.createContext({}),st=e=>{const{value:n}=e,s=E.useContext(Ue),c=$(n),r=E.useMemo(()=>c?n(s):n,[c,s,n]),a=E.useMemo(()=>c?r:nt(s,r),[c,s,r]),R=r&&r.provider,C=E.useRef(N);R&&!C.current&&(C.current=et(R(a.cache||pe),r));const h=C.current;return h&&(a.cache=h[0],a.mutate=h[1]),ce(()=>{if(h)return h[2]&&h[2](),h[3]},[]),E.createElement(Ue.Provider,te(e,{value:a}))},rt="$inf$",at=Ve&&window.__SWR_DEVTOOLS_USE__,Dt=at?window.__SWR_DEVTOOLS_USE__:[],mt=()=>{at&&(window.__SWR_DEVTOOLS_REACT__=be)},it=e=>$(e[1])?[e[0],e[1],e[2]||{}]:[e[0],null,(e[1]===null?e[2]:e[1])||{}],ot=()=>te(je,E.useContext(Ue)),wt=(e,n)=>{const[s,c]=ae(e),[,,,r]=Y.get(pe);if(r[s])return r[s];const a=n(c);return r[s]=a,a},Ot=e=>(n,s,c)=>e(n,s&&((...a)=>{const[R]=ae(n),[,,,C]=Y.get(pe);if(R.startsWith(rt))return s(...a);const h=C[R];return i(h)?s(...a):(delete C[R],h)}),c),bt=Dt.concat(Ot),ct=e=>function(...s){const c=ot(),[r,a,R]=it(s),C=nt(c,R);let h=e;const{use:W}=C,b=(W||[]).concat(bt);for(let D=b.length;D--;)h=b[D](h);return h(r,a||C.fetcher||null,C)},ut=(e,n,s)=>{const c=n[e]||(n[e]=[]);return c.push(s),()=>{const r=c.indexOf(s);r>=0&&(c[r]=c[c.length-1],c.pop())}},Vt=(e,n)=>(...s)=>{const[c,r,a]=it(s),R=(a.use||[]).concat(n);return e(c,r,{...a,use:R})};mt();const At=e=>ae(e)[0],Je=be.use||(e=>{if(e.status==="pending")throw e;if(e.status==="fulfilled")return e.value;throw e.status==="rejected"?e.reason:(e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e)}),Pe={dedupe:!0},It=(e,n,s)=>{const{cache:c,compare:r,suspense:a,fallbackData:R,revalidateOnMount:C,revalidateIfStale:h,refreshInterval:W,refreshWhenHidden:b,refreshWhenOffline:D,keepPreviousData:V}=s,[f,x,S,ue]=Y.get(c),[t,H]=ae(e),B=E.useRef(!1),U=E.useRef(!1),p=E.useRef(t),O=E.useRef(n),J=E.useRef(s),o=()=>J.current,k=()=>o().isVisible()&&o().isOnline(),[v,L,j,q]=re(c,t),A=E.useRef({}).current,ne=i(R)?s.fallback[t]:R,Q=(u,l)=>{for(const _ in A){const d=_;if(d==="data"){if(!r(u[d],l[d])&&(!i(u[d])||!r(Z,l[d])))return!1}else if(l[d]!==u[d])return!1}return!0},y=E.useMemo(()=>{const u=!t||!n?!1:i(C)?o().isPaused()||a?!1:i(h)?!0:h:C,l=T=>{const F=te(T);return delete F._k,u?{isValidating:!0,isLoading:!0,...F}:F},_=v(),d=q(),I=l(_),K=_===d?I:l(d);let g=I;return[()=>{const T=l(v());return Q(T,g)?(g.data=T.data,g.isLoading=T.isLoading,g.isValidating=T.isValidating,g.error=T.error,g):(g=T,T)},()=>K]},[c,t]),P=ze.useSyncExternalStore(E.useCallback(u=>j(t,(l,_)=>{Q(_,l)||u()}),[c,t]),y[0],y[1]),se=!B.current,Re=f[t]&&f[t].length>0,z=P.data,w=i(z)?ne:z,G=P.error,ie=E.useRef(w),Z=V?i(z)?ie.current:z:w,le=Re&&!i(G)?!1:se&&!i(C)?C:o().isPaused()?!1:a?i(w)?!1:h:i(w)||h,he=!!(t&&n&&se&&le),Ae=i(P.isValidating)?he:P.isValidating,Ie=i(P.isLoading)?he:P.isLoading,X=E.useCallback(async u=>{const l=O.current;if(!t||!l||U.current||o().isPaused())return!1;let _,d,I=!0;const K=u||{},g=!S[t]||!K.dedupe,T=()=>we?!U.current&&t===p.current&&B.current:t===p.current,F={isValidating:!1,isLoading:!1},ve=()=>{L(F)},_e=()=>{const m=S[t];m&&m[1]===d&&delete S[t]},Se={isValidating:!0};i(v().data)&&(Se.isLoading=!0);try{if(g&&(L(Se),s.loadingTimeout&&i(v().data)&&setTimeout(()=>{I&&T()&&o().onLoadingSlow(t,s)},s.loadingTimeout),S[t]=[l(H),Oe()]),[_,d]=S[t],_=await _,g&&setTimeout(_e,s.dedupingInterval),!S[t]||S[t][1]!==d)return g&&T()&&o().onDiscarded(t),!1;F.error=N;const m=x[t];if(!i(m)&&(d<=m[0]||d<=m[1]||m[1]===0))return ve(),g&&T()&&o().onDiscarded(t),!1;const M=v().data;F.data=r(M,_)?M:_,g&&T()&&o().onSuccess(_,t,s)}catch(m){_e();const M=o(),{shouldRetryOnError:fe}=M;M.isPaused()||(F.error=m,g&&T()&&(M.onError(m,t,M),(fe===!0||$(fe)&&fe(m))&&(!o().revalidateOnFocus||!o().revalidateOnReconnect||k())&&M.onErrorRetry(m,t,M,Le=>{const de=f[t];de&&de[0]&&de[0](ee.ERROR_REVALIDATE_EVENT,Le)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return I=!1,ve(),!0},[t,c]),ge=E.useCallback((...u)=>$e(c,p.current,...u),[]);if(ce(()=>{O.current=n,J.current=s,i(z)||(ie.current=z)}),ce(()=>{if(!t)return;const u=X.bind(N,Pe);let l=0;const d=ut(t,f,(I,K={})=>{if(I==ee.FOCUS_EVENT){const g=Date.now();o().revalidateOnFocus&&g>l&&k()&&(l=g+o().focusThrottleInterval,u())}else if(I==ee.RECONNECT_EVENT)o().revalidateOnReconnect&&k()&&u();else{if(I==ee.MUTATE_EVENT)return X();if(I==ee.ERROR_REVALIDATE_EVENT)return X(K)}});return U.current=!1,p.current=t,B.current=!0,L({_k:H}),le&&(i(w)||Ee?u():Ge(u)),()=>{U.current=!0,d()}},[t]),ce(()=>{let u;function l(){const d=$(W)?W(v().data):W;d&&u!==-1&&(u=setTimeout(_,d))}function _(){!v().error&&(b||o().isVisible())&&(D||o().isOnline())?X(Pe).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[W,b,D,t]),E.useDebugValue(Z),a&&i(w)&&t){if(!we&&Ee)throw new Error("Fallback data is required when using suspense in SSR.");O.current=n,J.current=s,U.current=!1;const u=ue[t];if(!i(u)){const l=ge(u);Je(l)}if(i(G)){const l=X(Pe);i(Z)||(l.status="fulfilled",l.value=!0),Je(l)}else throw G}return{mutate:ge,get data(){return A.data=!0,Z},get error(){return A.error=!0,G},get isValidating(){return A.isValidating=!0,Ae},get isLoading(){return A.isLoading=!0,Ie}}},Lt=Te.defineProperty(st,"defaultValue",{value:je}),yt=ct(It),kt=Object.freeze(Object.defineProperty({__proto__:null,SWRConfig:Lt,default:yt,mutate:tt,preload:wt,unstable_serialize:At,useSWRConfig:ot},Symbol.toStringTag,{value:"Module"})),Ye=be.use||(e=>{if(e.status==="pending")throw e;if(e.status==="fulfilled")return e.value;throw e.status==="rejected"?e.reason:(e.status="pending",e.then(n=>{e.status="fulfilled",e.value=n},n=>{e.status="rejected",e.reason=n}),e)}),Fe={dedupe:!0},Nt=(e,n,s)=>{const{cache:c,compare:r,suspense:a,fallbackData:R,revalidateOnMount:C,revalidateIfStale:h,refreshInterval:W,refreshWhenHidden:b,refreshWhenOffline:D,keepPreviousData:V}=s,[f,x,S,ue]=Y.get(c),[t,H]=ae(e),B=E.useRef(!1),U=E.useRef(!1),p=E.useRef(t),O=E.useRef(n),J=E.useRef(s),o=()=>J.current,k=()=>o().isVisible()&&o().isOnline(),[v,L,j,q]=re(c,t),A=E.useRef({}).current,ne=i(R)?s.fallback[t]:R,Q=(u,l)=>{for(const _ in A){const d=_;if(d==="data"){if(!r(u[d],l[d])&&(!i(u[d])||!r(Z,l[d])))return!1}else if(l[d]!==u[d])return!1}return!0},y=E.useMemo(()=>{const u=!t||!n?!1:i(C)?o().isPaused()||a?!1:i(h)?!0:h:C,l=T=>{const F=te(T);return delete F._k,u?{isValidating:!0,isLoading:!0,...F}:F},_=v(),d=q(),I=l(_),K=_===d?I:l(d);let g=I;return[()=>{const T=l(v());return Q(T,g)?(g.data=T.data,g.isLoading=T.isLoading,g.isValidating=T.isValidating,g.error=T.error,g):(g=T,T)},()=>K]},[c,t]),P=ze.useSyncExternalStore(E.useCallback(u=>j(t,(l,_)=>{Q(_,l)||u()}),[c,t]),y[0],y[1]),se=!B.current,Re=f[t]&&f[t].length>0,z=P.data,w=i(z)?ne:z,G=P.error,ie=E.useRef(w),Z=V?i(z)?ie.current:z:w,le=Re&&!i(G)?!1:se&&!i(C)?C:o().isPaused()?!1:a?i(w)?!1:h:i(w)||h,he=!!(t&&n&&se&&le),Ae=i(P.isValidating)?he:P.isValidating,Ie=i(P.isLoading)?he:P.isLoading,X=E.useCallback(async u=>{const l=O.current;if(!t||!l||U.current||o().isPaused())return!1;let _,d,I=!0;const K=u||{},g=!S[t]||!K.dedupe,T=()=>we?!U.current&&t===p.current&&B.current:t===p.current,F={isValidating:!1,isLoading:!1},ve=()=>{L(F)},_e=()=>{const m=S[t];m&&m[1]===d&&delete S[t]},Se={isValidating:!0};i(v().data)&&(Se.isLoading=!0);try{if(g&&(L(Se),s.loadingTimeout&&i(v().data)&&setTimeout(()=>{I&&T()&&o().onLoadingSlow(t,s)},s.loadingTimeout),S[t]=[l(H),Oe()]),[_,d]=S[t],_=await _,g&&setTimeout(_e,s.dedupingInterval),!S[t]||S[t][1]!==d)return g&&T()&&o().onDiscarded(t),!1;F.error=N;const m=x[t];if(!i(m)&&(d<=m[0]||d<=m[1]||m[1]===0))return ve(),g&&T()&&o().onDiscarded(t),!1;const M=v().data;F.data=r(M,_)?M:_,g&&T()&&o().onSuccess(_,t,s)}catch(m){_e();const M=o(),{shouldRetryOnError:fe}=M;M.isPaused()||(F.error=m,g&&T()&&(M.onError(m,t,M),(fe===!0||$(fe)&&fe(m))&&(!o().revalidateOnFocus||!o().revalidateOnReconnect||k())&&M.onErrorRetry(m,t,M,Le=>{const de=f[t];de&&de[0]&&de[0](ee.ERROR_REVALIDATE_EVENT,Le)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return I=!1,ve(),!0},[t,c]),ge=E.useCallback((...u)=>$e(c,p.current,...u),[]);if(ce(()=>{O.current=n,J.current=s,i(z)||(ie.current=z)}),ce(()=>{if(!t)return;const u=X.bind(N,Fe);let l=0;const d=ut(t,f,(I,K={})=>{if(I==ee.FOCUS_EVENT){const g=Date.now();o().revalidateOnFocus&&g>l&&k()&&(l=g+o().focusThrottleInterval,u())}else if(I==ee.RECONNECT_EVENT)o().revalidateOnReconnect&&k()&&u();else{if(I==ee.MUTATE_EVENT)return X();if(I==ee.ERROR_REVALIDATE_EVENT)return X(K)}});return U.current=!1,p.current=t,B.current=!0,L({_k:H}),le&&(i(w)||Ee?u():Ge(u)),()=>{U.current=!0,d()}},[t]),ce(()=>{let u;function l(){const d=$(W)?W(v().data):W;d&&u!==-1&&(u=setTimeout(_,d))}function _(){!v().error&&(b||o().isVisible())&&(D||o().isOnline())?X(Fe).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[W,b,D,t]),E.useDebugValue(Z),a&&i(w)&&t){if(!we&&Ee)throw new Error("Fallback data is required when using suspense in SSR.");O.current=n,J.current=s,U.current=!1;const u=ue[t];if(!i(u)){const l=ge(u);Ye(l)}if(i(G)){const l=X(Fe);i(Z)||(l.status="fulfilled",l.value=!0),Ye(l)}else throw G}return{mutate:ge,get data(){return A.data=!0,Z},get error(){return A.error=!0,G},get isValidating(){return A.isValidating=!0,Ae},get isLoading(){return A.isLoading=!0,Ie}}};Te.defineProperty(st,"defaultValue",{value:je});const Pt=ct(Nt),Ft=e=>ae(e?e(0,null):null)[0],Me=Promise.resolve(),Mt=e=>(n,s,c)=>{const r=E.useRef(!1),{cache:a,initialSize:R=1,revalidateAll:C=!1,persistSize:h=!1,revalidateFirstPage:W=!0,revalidateOnMount:b=!1,parallel:D=!1}=c,[,,,V]=Y.get(pe);let f;try{f=Ft(n),f&&(f=rt+f)}catch{}const[x,S,ue]=re(a,f),t=E.useCallback(()=>i(x()._l)?R:x()._l,[a,f,R]);ze.useSyncExternalStore(E.useCallback(o=>f?ue(f,()=>{o()}):()=>{},[a,f]),t,t);const H=E.useCallback(()=>{const o=x()._l;return i(o)?R:o},[f,R]),B=E.useRef(H());ce(()=>{if(!r.current){r.current=!0;return}f&&S({_l:h?B.current:H()})},[f,a]);const U=b&&!r.current,p=e(f,async o=>{const k=x()._i,v=x()._r;S({_r:N});const L=[],j=H(),[q]=re(a,o),A=q().data,ne=[];let Q=null;for(let y=0;y<j;++y){const[P,se]=ae(n(y,D?null:Q));if(!P)break;const[Re,z]=re(a,P);let w=Re().data;const G=C||k||i(w)||W&&!y&&!i(A)||U||A&&!i(A[y])&&!c.compare(A[y],w);if(s&&(typeof v=="function"?v(w,se):G)){const ie=async()=>{if(!(P in V))w=await s(se);else{const le=V[P];delete V[P],w=await le}z({data:w,_k:se}),L[y]=w};D?ne.push(ie):await ie()}else L[y]=w;D||(Q=w)}return D&&await Promise.all(ne.map(y=>y())),S({_i:N}),L},c),O=E.useCallback(function(o,k){const v=typeof k=="boolean"?{revalidate:k}:k||{},L=v.revalidate!==!1;return f?(L&&(i(o)?S({_i:!0,_r:v.revalidate}):S({_i:!1,_r:v.revalidate})),arguments.length?p.mutate(o,{...v,revalidate:L}):p.mutate()):Me},[f,a]),J=E.useCallback(o=>{if(!f)return Me;const[,k]=re(a,f);let v;if($(o)?v=o(H()):typeof o=="number"&&(v=o),typeof v!="number")return Me;k({_l:v}),B.current=v;const L=[],[j]=re(a,f);let q=null;for(let A=0;A<v;++A){const[ne]=ae(n(A,q)),[Q]=re(a,ne),y=ne?Q().data:N;if(i(y))return O(j().data);L.push(y),q=y}return O(L)},[f,a,O,H]);return{size:H(),setSize:J,mutate:O,get data(){return p.data},get error(){return p.error},get isValidating(){return p.isValidating},get isLoading(){return p.isLoading}}},qt=Vt(Pt,Mt);export{Lt as S,qt as a,kt as s,yt as u};
